<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Advent Calendar | LESS IS MORE</title>
    <link>https://r9y9.github.io/tag/advent-calendar/</link>
      <atom:link href="https://r9y9.github.io/tag/advent-calendar/index.xml" rel="self" type="application/rss+xml" />
    <description>Advent Calendar</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Copyright © Ryuichi YAMAMOTO All rights reserved.</copyright><lastBuildDate>Thu, 21 Dec 2017 00:00:00 +0900</lastBuildDate>
    <image>
      <url>https://r9y9.github.io/media/icon_hu80af6620f812c701b45cf64bd91e2f1f_1204_512x512_fill_lanczos_center_3.png</url>
      <title>Advent Calendar</title>
      <link>https://r9y9.github.io/tag/advent-calendar/</link>
    </image>
    
    <item>
      <title>Interactive C&#43;&#43;: Jupyter上で対話的にC&#43;&#43;を使う方法の紹介 [Jupyter Advent Calendar 2017]</title>
      <link>https://r9y9.github.io/blog/2017/12/21/jupyter-cxx/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0900</pubDate>
      <guid>https://r9y9.github.io/blog/2017/12/21/jupyter-cxx/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter-cxx/jupyter-cxx-demo.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2017/jupyter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter Advent Calendar 2017&lt;/a&gt; 21日目の記事です。&lt;/p&gt;
&lt;p&gt;C++をJupyterで使う方法はいくつかあります。この記事では、僕が試したことのある以下の4つの方法について、比較しつつ紹介したいと思います。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/root-project/cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;root/cling&lt;/a&gt; 付属のカーネル&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/root-project/cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;root/root&lt;/a&gt; 付属のカーネル&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/QuantStack/xeus-cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xeus-cling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Keno/Cxx.jl&lt;/a&gt; をIJuliaで使う&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まとめとして、簡単に特徴などを表にまとめておきますので、選ぶ際の参考にしてください。詳細な説明は後に続きます。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://github.com/root-project/cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cling&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://github.com/root-project/root&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ROOT&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://github.com/QuantStack/xeus-cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xeus-cling&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;%28https://github.com/Keno/Cxx.jl%29&#34;&gt;Cxx.jl&lt;/a&gt; + &lt;a href=&#34;https://github.com/JuliaLang/IJulia.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IJulia&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++インタプリタ実装&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;Julia + C++&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(Tab) Code completion&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cインタプリタ&lt;/td&gt;
&lt;td&gt;△&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;△&lt;/td&gt;
&lt;td&gt;△&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%magics&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;%%cpp, %%jsroot, その他&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;△&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;他言語との連携&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Python, R &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Julia&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;バイナリ配布&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://root.cern.ch/download/cling/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式リンク&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://root.cern.ch/downloading-root&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式リンク&lt;/a&gt; (python2系向け）&lt;/td&gt;
&lt;td&gt;condaで提供&lt;/td&gt;
&lt;td&gt;△&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;オンラインデモ&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://swanserver.web.cern.ch/swanserver/rootdemo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rootdemo&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://mybinder.org/v2/gh/QuantStack/xeus-cling/0.0.7-binder?filepath=notebooks%2Fxcpp.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;binderリンク&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;共通事項&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;すべて、clang/llvmをC++インタプリタのベースにしています。Cxx.jl以外は、C++インタプリタであるclingをベースに、さらにその上にjupyterカーネルを実装しています。&lt;/p&gt;
&lt;h2 id=&#34;1-cling&#34;&gt;1. cling&lt;/h2&gt;
&lt;p&gt;clingは、いわずとしれた（？）C++インタプリタ実装です。後述するROOTという data analysis framework の一部として、CERNによって開発されています。(20年くらい前の) 古くからあったCINTというC++インタプリタ実装が、clangを使って書き直された、という歴史があります。clingプロジェクトの一環としてJupyterカーネルが開発されています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良いところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clingの起動が速いのでストレスが少ない &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;イマイチなところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPythonだと使える &lt;code&gt;%time&lt;/code&gt; のようなマジックはない&lt;/li&gt;
&lt;li&gt;cling本体で良いのでは？感が否めない。cling本体のREPLを使えば、Ctrl+Rによるヒストリ検索も使えるし…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使ってみた感想まとめ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;個人的には、Jupyterは可視化と組み合わせてこそ良さがあると思っているのもありますが、あえてJupyterで使う必要性を僕は感じませんでした。cling自体はとても素晴らしいのと、ノートブックとして実行結果ごとコードを保存したい、といった目的でjupyterを使う場合には、良いと思いました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; のあとにcode completionをしようとするとclingが落ちる、というバグがあります。Jupyterの場合はカーネルがリスタートします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vgvassilev/cling/issues/152&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/vgvassilev/cling/issues/152&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参考リンク&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式web: &lt;a href=&#34;https://cdn.rawgit.com/root-project/cling/master/www/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cdn.rawgit.com/root-project/cling/master/www/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github: &lt;a href=&#34;https://github.com/root-project/cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/root-project/cling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;紹介スライド: &lt;a href=&#34;http://llvm.org/devmtg/2010-11/Naumann-Cling.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LLVM Developers&#39; Meeting, &amp;ldquo;Creating cling, an interactive interpreter interface for clang&amp;rdquo;, Axel Naumann, Philippe Canal, Paul Russo, Vassil Vassilev, 04.11.2010, San Jose, CA, United States&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-root&#34;&gt;2. ROOT&lt;/h2&gt;
&lt;p&gt;ROOTの説明を公式ページから引用します：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A modular scientific software framework. It provides all the functionalities needed to deal with big data processing, statistical analysis, visualisation and storage. It is mainly written in C++ but integrated with other languages such as Python and R.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日本語の情報が少ない印象ですが、&lt;a href=&#34;https://github.com/akira-okumura/RHEA/wiki/ROOT-%E8%AC%9B%E7%BF%92%E4%BC%9A-2017&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ROOT 講習会 2017 | 高エネルギー宇宙物理学のための ROOT 入門 – ROOT for High-Energy Astrophysics (RHEA)&lt;/a&gt; によると、実験系素粒子物理学では標準的なデータ解析ソフトウェア・ライブラリ群のようです。&lt;/p&gt;
&lt;p&gt;ROOTプロジェクト自体にclingを含みますが、clingが提供するjupyterカーネルとは別で、&lt;a href=&#34;https://github.com/root-project/root/tree/master/bindings/pyroot/JupyROOT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JupyROOT&lt;/a&gt; というカーネルが開発されています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良いところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PythonとC++をミックスできる。&lt;code&gt;%%cpp&lt;/code&gt; magicでC++関数を定義して、ホスト（python) 側から呼び出せる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%%jsroot&lt;/code&gt; magic により、グラフをインタラクティブに動かせる&lt;/li&gt;
&lt;li&gt;IPythonで使えるmagicが使える（&lt;code&gt;%timeit&lt;/code&gt;, &lt;code&gt;%time&lt;/code&gt;, &lt;code&gt;%load_ext&lt;/code&gt;等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;イマイチなところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Numpyやmatplotlibなど、Pythonを用いた数値計算ではデファクトに近いツールとの連携は微妙に思いました &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。cythonのように、手軽にnumpy arrayをC++に渡す、といった方法はなさそう・・・？（あったら教えてください）&lt;/li&gt;
&lt;li&gt;ROOTの（でかい）APIを覚えないと使えなさそうで、ハードルが高い&lt;/li&gt;
&lt;li&gt;公式のbinderのデモノートブック、ちょいちょいカーネルが落ちる…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使ってみた感想まとめ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jupyterカーネルはclingのものよりも良いと思いました。PythonとC++をミックスできるのが特に良いと思います。個人的には、ROOTが機能もりもりのデカイソフトウェアなことがあまり好きになれず、使い込んでいないのですが、ROOTのAPIに慣れた人、あるいは好きになれる人には、良いと思います。&lt;/p&gt;
&lt;p&gt;clingだと &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt;のあとにcode completionで落ちる、というバグがありまたが、ROOT付属のcling (&lt;code&gt;ROOT 6.10/08&lt;/code&gt; をソースからビルドして使いました) ではそのバグはありませんでした。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考リンク&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式ページ: &lt;a href=&#34;https://root.cern.ch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://root.cern.ch/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github: &lt;a href=&#34;https://github.com/root-project/root&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/root-project/root&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;オンラインデモ: &lt;a href=&#34;https://swanserver.web.cern.ch/swanserver/rootdemo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://swanserver.web.cern.ch/swanserver/rootdemo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-xeus-cling&#34;&gt;3. xeus-cling&lt;/h2&gt;
&lt;p&gt;先月 11月30日に、&lt;a href=&#34;https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter blog で紹介&lt;/a&gt; されたカーネルです。名前の通りclingをベースにしています。C++インタプリタとしては機能的にcling付属カーネルと同じですが、&lt;a href=&#34;https://github.com/QuantStack/xeus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xeus&lt;/a&gt; というJupyter kernel protocolのC++実装をベースにしている点が異なります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;良いところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;condaでパッケージとして提供されているので、インストールが楽。clang/clingも併せてインストールしてくれます&lt;/li&gt;
&lt;li&gt;同じ開発元が、&lt;a href=&#34;https://github.com/QuantStack/xplot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xplot&lt;/a&gt; という可視化ライブラリを提供している（ただしalphaバージョン）&lt;/li&gt;
&lt;li&gt;標準ライブラリのヘルプが &lt;code&gt;?&lt;/code&gt; コマンドで確認できます (例. &lt;code&gt;?std::vector&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;イマイチなところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部ライブラリをロードしようとしたら動きませんでした（なので &lt;a href=&#34;https://github.com/QuantStack/xeus-cling/pull/94&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;プルリク&lt;/a&gt; 投げました（が、いい方法ではなかったようでcloseされました&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%timeit&lt;/code&gt; の実装があったので試してみましたが、エラーが出て動きませんでした&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使ってみた感想まとめ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;少しalphaバージョンの印象を受けました。xplotなど周辺ツールへの期待がありますが、個人的にはmatplotlib等pythonの可視化ツールでいいのでは…という気持ちになりました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考リンク&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&#34;https://github.com/QuantStack/xeus-cling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/QuantStack/xeus-cling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;紹介記事: &lt;a href=&#34;https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-cxxjl--ijuliajl&#34;&gt;4. Cxx.jl + IJulia.jl&lt;/h2&gt;
&lt;p&gt;Cxx.jlは、clangをベースにしたJuliaのC++インタフェースです。JuliaにはIJuliaというJupyterカーネルの実装があるので、IJuliaとCxx.jlを使えば、Jupyter上でC++を使うことができます。過去にCxx.jlに関する記事をいくつか書きましたので、そのリンクを貼っておきます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r9y9.github.io/blog/2016/01/24/passing-julia-expressions-to-cxx/&#34;&gt;Cxx.jlを用いてJulia expression/value をC++に埋め込む実験 | LESS IS MORE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://r9y9.github.io/blog/2015/12/22/cxx-jl/&#34;&gt;Cxx.jl を使ってみた感想 + OpenCV.jl, Libfreenect2.jl の紹介 | LESS IS MORE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;良いところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JuliaとC++をミックスできます。過去記事に書きましたが、例えばC++関数内でJuliaのプログレスバーを使ったりできます&lt;/li&gt;
&lt;li&gt;C++インタプリタとCインタプリタを切り替えられます&lt;/li&gt;
&lt;li&gt;&lt;code&gt;icxx&lt;/code&gt; と &lt;code&gt;cxx&lt;/code&gt; マクロで、それぞれローカル/グローバルスコープを切り替えられます。&lt;/li&gt;
&lt;li&gt;Juliaの配列をC++に渡すのは非常に簡単にできます。例を以下に示します&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;C++ &amp;gt; #include &amp;lt;iostream&amp;gt;
true

julia&amp;gt; cxx&amp;quot;&amp;quot;&amp;quot;
       template &amp;lt;class T&amp;gt;
       void f(T x, int n) {
           for (int i = 0; i &amp;lt; n; ++i) {
               std::cout &amp;lt;&amp;lt; x[i] &amp;lt;&amp;lt; std::endl;
           }
       }&amp;quot;&amp;quot;&amp;quot;;

julia&amp;gt; x = rand(5)
10-element Array{Float64,1}:
 0.593086
 0.736548
 0.344246
 0.390799
 0.226175

julia&amp;gt; icxx&amp;quot;f($(pointer(x)), $(length(x)));&amp;quot;
0.593086
0.736548
0.344246
0.390799
0.226175
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;イマイチなところ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cxxパッケージを読み込むのに多少時間がかかります。僕の環境では（プリコンパイルされた状態で）2.5秒程度でした&lt;/li&gt;
&lt;li&gt;(Tab) Code completionは実装されていません &lt;a href=&#34;https://github.com/Keno/Cxx.jl/issues/61&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#61&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;icxx&lt;/code&gt; or &lt;code&gt;cxx&lt;/code&gt; で囲まないといけず、syntax highlightはされません&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使ってみた感想まとめ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;僕は一年以上Cxx.jlを使っているので、バイアスも入っていると思いますが、かなり使いやすいと思います。パッケージのロードに時間がかかるのは、何度もカーネルやjuliaを再起動したりしなければ、まったく気になりません。&lt;a href=&#34;https://github.com/JuliaLang/IJulia.jl/blob/42d103eaa89d8cf1ab3bc0a8ee0e298bb9a91f80/src/magics.jl#L1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IJuliaの設計上の理由&lt;/a&gt; により、magicはありませんが、例えば &lt;code&gt;%time&lt;/code&gt; は &lt;code&gt;@time&lt;/code&gt; マクロで十分であり、不便に感じません。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考リンク&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IJulia: &lt;a href=&#34;https://github.com/JuliaLang/IJulia.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/JuliaLang/IJulia.jl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cxx : &lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/Keno/Cxx.jl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++と他言語のやりとりのスムースさの観点から、やはり僕は対話環境でC++を使うならCxx.jlが最高だと思いました。Cxx + JuliaのREPLも便利ですが、Cxx + IJuliaも良いと思います。&lt;/li&gt;
&lt;li&gt;ただし、C++単体でしか使わない、ということであれば、cling or xeus-clingが良いと思います。ただし xeus-clingは、前述の通り外部ライブラリを読みこもうとするとエラーになる問題があったので、外部ライブラリを読み込んで使用したい場合はパッチ (&lt;a href=&#34;https://github.com/QuantStack/xeus-cling/pull/94&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xeus-cling/#94&lt;/a&gt;) を当てた方がよいかもしれません&lt;/li&gt;
&lt;li&gt;xeus-clingには、Jupyterブログにのっていたのでどんなものかと思って試してみましたが、周辺ツール含め思ってたよりalpha版のようでした。また、他と比べての機能的な優位性はあまり感じませんでした。ただし、condaパッケージとして提供されているので、敷居が一番低いのは嬉しいですね&lt;/li&gt;
&lt;li&gt;ROOTのjupyter kernelは、C++とpythonをミックスできるのが特に良く、素晴らしいと思いました。また &lt;code&gt;%%cpp&lt;/code&gt; magicの他にも、ipythonで使える &lt;code&gt;%timeit&lt;/code&gt; などのmagicも使えるのは、ユーザにとっては嬉しいです。Cxx.jlを除けば、ROOTのカーネルが一番良いと思いました。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interactive Workflows for C++ with Jupyter – Jupyter Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/mugwort_rc/items/b8087d1b6f9498b037d5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C++11/14/17インタプリタ環境 Jupyter-Cling - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/sasaki77/items/f6253e1d6638fba0e744&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JupyterにC++のノートのためのclingカーネルを追加する [Mac] - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/akira-okumura/RHEA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;高エネルギー宇宙物理学のための ROOT 入門 – ROOT for High-Energy Astrophysics (RHEA)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;clangをベースにしているので原理的には可能だと思いますが、少なくともjupyterカーネルとしてはありません&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Juliaのmacroを使えばよい、というスタンスで、提供していません。 &lt;a href=&#34;https://github.com/JuliaLang/IJulia.jl/blob/42d103eaa89d8cf1ab3bc0a8ee0e298bb9a91f80/src/magics.jl#L1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考リンク&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://root.cern.ch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式ホームページ&lt;/a&gt; より引用: It is mainly written in C++ but integrated with other languages such as Python and R.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;linux向け&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Cxx.jlだと、パッケージのコンパイルに10秒かかる、とか過去にありました。最近は改善されていますが&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rootpy/rootpy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/rootpy/rootpy&lt;/a&gt; ライブラリはありますが、結局このライブラリのAPIを覚えないといけないという…はい…&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>ニューラルネットの学習過程の可視化を題材に、Jupyter &#43; Bokeh で動的な描画を行う方法の紹介 [Jupyter Advent Calendar 2017]</title>
      <link>https://r9y9.github.io/blog/2017/12/14/jupyter-bokeh/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:30 +0900</pubDate>
      <guid>https://r9y9.github.io/blog/2017/12/14/jupyter-bokeh/</guid>
      <description>&lt;p&gt;Line &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/line.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/line.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_3_1.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;VBar &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/vbar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/vbar.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_3_3.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;HBar &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/hbar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/hbar.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_3_5.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ImageRGBA &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/image_rgba.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/image_rgba.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_3_7.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ImageRGBA &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/image_rgba.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/image_rgba.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_3_9.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;前置き&#34;&gt;前置き&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2017/jupyter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter Advent Calendar 2017&lt;/a&gt; 14日目の記事です。この記事は、Jupyter notebookで作成したものをnbconvertでmarkdownに変換し、手で少し修正して作りました。読み物としてはこの記事を、実行するにはノートブックの方を参照していただくのが良いかと思います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/r9y9/d57e797c28f6cdc4e44264411c21b76f&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ノートブック (gist)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/gist/r9y9/d57e797c28f6cdc4e44264411c21b76f&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nbviewer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;
&lt;p&gt;適当なニューラルネットの学習過程の可視化（ロス、正解率の遷移等）を題材にして、&lt;a href=&#34;https://bokeh.pydata.org/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bokeh&lt;/a&gt;を使って動的にグラフを更新していくことによる可視化の実用例を紹介します。このノートブックの冒頭に、最後まで実行すると得られるグラフ一覧をまとめました。どうやってグラフを作るのか知りたい方は続きを読んでもらえればと思います。Bokehの詳細な使い方は、公式ドキュメントを参考にしてください。&lt;/p&gt;
&lt;p&gt;なお、ここで紹介する例は、僕が過去に出た機械学習のコンペ (&lt;a href=&#34;https://deepanalytics.jp/compe/36?tab=compedetail&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://deepanalytics.jp/compe/36?tab=compedetail&lt;/a&gt;) で実際に使用したコードからほぼ取ってきました（8/218位でした）。グラフを動的に更新する方法は &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html#notebook-handles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式ドキュメント&lt;/a&gt; に記述されていますが、そのサンプルの内容は「円を描画して色を変える」といった実用性皆無のものであること、またググっても例が多く見つからないことから、このような紹介記事を書くことにしました。参考になれば幸いです。&lt;/p&gt;
&lt;p&gt;余談ではありますが、こと機械学習に関しては、tensorboardを使ったほうが簡単で良いと思います。僕は最近そうしています。 &lt;a href=&#34;https://qiita.com/r9y9/items/d54162d37ec4f110f4b4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://qiita.com/r9y9/items/d54162d37ec4f110f4b4&lt;/a&gt;. 色なり位置なり大きさなりを柔軟にカスタマイズしたい、あるいはノートブックで処理を完結させたい、と言った場合には、ここで紹介する方法も良いかもしれません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;%pylab inline
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Populating the interactive namespace from numpy and matplotlib
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.display import HTML, Image
import IPython
from os.path import exists

def summary():
    baseurl = &amp;quot;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/&amp;quot;
    for (name, figname, url) in [
        (&amp;quot;Line&amp;quot;, &amp;quot;line&amp;quot;, &amp;quot;line.html&amp;quot;),
        (&amp;quot;VBar&amp;quot;, &amp;quot;vbar&amp;quot;, &amp;quot;vbar.html&amp;quot;),
        (&amp;quot;HBar&amp;quot;, &amp;quot;hbar&amp;quot;, &amp;quot;hbar.html&amp;quot;),
        (&amp;quot;ImageRGBA&amp;quot;, &amp;quot;gray_image&amp;quot;, &amp;quot;image_rgba.html&amp;quot;),
        (&amp;quot;ImageRGBA&amp;quot;, &amp;quot;inferno_image&amp;quot;, &amp;quot;image_rgba.html&amp;quot;),
        ]:
        gif = &amp;quot;./fig/{}.gif&amp;quot;.format(figname)
        print(&amp;quot;\n&amp;quot;,name, baseurl + url)
        if exists(gif):
            with open(gif, &#39;rb&#39;) as f:
                IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)

summary()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(※ブログ先頭に貼ったので省略します)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# True にしてノートブックを実行すると、上記gifの元となる画像を保存し、最後にgifを生成する
save_img = False
if save_img:
    import os
    from os.path import exists
    if not exists(&amp;quot;./fig&amp;quot;):
        os.makedirs(&amp;quot;./fig&amp;quot;)
    toolbar_location = None
else:
    toolbar_location = &amp;quot;above&amp;quot;

# bokehで描画したグラフはnotebookに残らないので、Trueの場合は代わりに事前に保存してあるgifを描画する
# もしローカルで実行するときは、Falseにしてください
show_static = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;
&lt;p&gt;先述の通り、ニューラルネットの学習過程の可視化を題材として、Jupyter上でのBokehの使い方を紹介していきたいと思います。今回は、PyTorch (v0.3.0) を使ってニューラルネットの学習のコードを書きました。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pytorch/examples/tree/master/mnist&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/pytorch/examples/tree/master/mnist&lt;/a&gt; をベースに、可視化しやすいように少しいじりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms
from torch.autograd import Variable
import numpy as np
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;data&#34;&gt;Data&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;use_cuda = torch.cuda.is_available()

batch_size = 128

kwargs = {&#39;num_workers&#39;: 1, &#39;pin_memory&#39;: True} if use_cuda else {}
train_loader = torch.utils.data.DataLoader(
    datasets.MNIST(&#39;./data&#39;, train=True, download=True,
                   transform=transforms.Compose([
                       transforms.ToTensor()
                   ])),
    batch_size=batch_size, shuffle=True, **kwargs)
test_loader = torch.utils.data.DataLoader(
    datasets.MNIST(&#39;./data&#39;, train=False, transform=transforms.Compose([
                       transforms.ToTensor(),
                   ])),
    batch_size=batch_size, shuffle=False, **kwargs)

data_loaders = {&amp;quot;train&amp;quot;: train_loader, &amp;quot;test&amp;quot;:test_loader}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;model&#34;&gt;Model&lt;/h3&gt;
&lt;p&gt;簡単な畳み込みニューラルネットです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)
        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)
        self.conv2_drop = nn.Dropout2d()
        self.fc1 = nn.Linear(320, 50)
        self.fc2 = nn.Linear(50, 10)

    def forward(self, x):
        x = F.relu(F.max_pool2d(self.conv1(x), 2))
        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))
        x = x.view(-1, 320)
        x = F.relu(self.fc1(x))
        x = F.dropout(x, training=self.training)
        x = self.fc2(x)
        return F.log_softmax(x, dim=-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;train-loop&#34;&gt;Train loop&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tqdm import tnrange
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;epochs = 20

def __train_loop(model, data_loaders, optimizer, epoch, phase):
    model = model.train() if phase == &amp;quot;train&amp;quot; else model.eval()
    running_loss = 0
    running_corrects = 0
    corrects = [0]*10
    counts = [0]*10
    for batch_idx, (x, y) in enumerate(data_loaders[phase]):
        x = x.cuda() if use_cuda else x
        y = y.cuda() if use_cuda else y
        x, y = Variable(x), Variable(y)
        optimizer.zero_grad()
        y_hat = model(x)

        # loss
        loss = F.nll_loss(y_hat, y)

        # update
        if phase == &amp;quot;train&amp;quot;:
            loss.backward()
            optimizer.step()
        running_loss += loss.data[0]

        # predict
        preds = torch.max(y_hat.data, 1)[1]
        match = (preds == y.data).cpu()
        running_corrects += match.sum()

        # カテゴリごとの正解率を出すのにほしい
        for i in range(len(match)):
            if match.view(-1)[i] &amp;gt; 0:
                corrects[y.data.view(-1)[i]] += 1
        for i in range(len(match)):
            counts[y.data.view(-1)[i]] += 1

    # epoch-wise metrics
    l = running_loss / len(data_loaders[phase])
    acc = running_corrects / len(data_loaders[phase].dataset)
    return {&amp;quot;loss&amp;quot;: l, &amp;quot;acc&amp;quot;: acc, &amp;quot;corrects&amp;quot;: corrects, &amp;quot;counts&amp;quot;: counts}

def train_loop(model, data_loaders, optimizer, epochs=12, callback=None):
    history = {&amp;quot;train&amp;quot;: {}, &amp;quot;test&amp;quot;: {}}
    for epoch in tnrange(epochs):
        for phase in [&amp;quot;train&amp;quot;, &amp;quot;test&amp;quot;]:
            d = __train_loop(model, data_loaders, optimizer, epoch, phase)
            for k,v in d.items():
                try:
                    history[phase][k].append(v)
                except KeyError:
                    history[phase][k] = [v]

            # ここでグラフの更新を呼ぶ想定です
            if callback is not None:
                callback.on_epoch_end(epoch, phase, history)
    return history
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;本編&#34;&gt;本編&lt;/h2&gt;
&lt;h3 id=&#34;0-matplotlib&#34;&gt;0. Matplotlib&lt;/h3&gt;
&lt;p&gt;まずはじめに、動的ではない（静的な）グラフの例を示します。手書き数字認識のような識別タスクにおいて、最も一般的であると思われる評価尺度として、ロスと正解率を可視化します。&lt;code&gt;train_loop&lt;/code&gt;関数は、返り値にロスと正解率のhistoryを返すようにしたので、それを使ってグラフを作ります。&lt;/p&gt;
&lt;p&gt;図の作成にはいろんなツールがあると思うのですが、matplotlibが定番で（僕は）大きな不満もないので、よく使っています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = Net().cuda() if use_cuda else Net()
optimizer = optim.Adadelta(model.parameters())
history = train_loop(model, data_loaders, optimizer, epochs)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
print(&amp;quot;Test acc: {:.3f}&amp;quot;.format(history[&amp;quot;test&amp;quot;][&amp;quot;acc&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.111
Test acc: 0.989
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;matplotlib.pyplot.figure(figsize=(16,6))
subplot(1,2,1)
plot(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;], linewidth=3, color=&amp;quot;red&amp;quot;, label=&amp;quot;train loss&amp;quot;)
plot(history[&amp;quot;test&amp;quot;][&amp;quot;loss&amp;quot;], linewidth=3, color=&amp;quot;blue&amp;quot;, label=&amp;quot;test lsos&amp;quot;)
xlabel(&amp;quot;epoch&amp;quot;, fontsize=16)
legend(prop={&amp;quot;size&amp;quot;: 16})
subplot(1,2,2)
plot(history[&amp;quot;train&amp;quot;][&amp;quot;acc&amp;quot;], linewidth=3, color=&amp;quot;red&amp;quot;, label=&amp;quot;train acc&amp;quot;)
plot(history[&amp;quot;test&amp;quot;][&amp;quot;acc&amp;quot;], linewidth=3, color=&amp;quot;blue&amp;quot;, label=&amp;quot;test acc&amp;quot;)
xlabel(&amp;quot;epoch&amp;quot;, fontsize=16)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.text.Text at 0x7f16fa9ca438&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_16_1.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;1-line&#34;&gt;1. Line&lt;/h3&gt;
&lt;p&gt;次に、上記の線グラフを、Bokehを使って作ってみます。これには、 &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/line.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/line.html&lt;/a&gt; が使えます。&lt;/p&gt;
&lt;p&gt;bokehで作ったグラフをnotebookにinline plotするためには、&lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/io.html#bokeh.io.output_notebook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bokeh.io.output_notebook&lt;/a&gt; を呼び出しておく必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import bokeh
import bokeh.io
from bokeh.io import push_notebook, show, output_notebook
from bokeh.plotting import figure
try:
    # 少し古いbokehだとこっち
    from bokeh.io import gridplot
except ImportError:
    from bokeh.layouts import gridplot

output_notebook()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に定義する &lt;code&gt;LinePlotsCallback&lt;/code&gt; は、グラフの情報をプロパティに保持し、&lt;code&gt;on_epoch_end&lt;/code&gt; で学習結果のhisotoryを受け取って、ロスと正解率のグラフを更新します。 historyには、今回の場合は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ロス (float)&lt;/li&gt;
&lt;li&gt;正解率 (float)&lt;/li&gt;
&lt;li&gt;カテゴリ毎の総サンプル数 (list)&lt;/li&gt;
&lt;li&gt;カテゴリ毎の正解サンプル数 (list)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の4つを含めるように実装しました (&lt;code&gt;train_loop&lt;/code&gt; 関数を参照)。&lt;code&gt;LinePlotsCallback&lt;/code&gt; では、このうちロスと正解率を随時受け取って、グラフを更新します。&lt;code&gt;Line&lt;/code&gt; オブジェクトの更新には、&lt;code&gt;data_source.data[&amp;quot;x&amp;quot;]&lt;/code&gt;, &lt;code&gt;data_source.data[&amp;quot;y&amp;quot;]&lt;/code&gt; に随時値を追加していくことで行います。&lt;/p&gt;
&lt;p&gt;以降示すグラフでも同じなのですが、グラフを生成する基本的な手順をまとめると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/plotting.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bokeh.plotting.figure&lt;/a&gt; により、figureオブジェクトを生成する&lt;/li&gt;
&lt;li&gt;生成したfigureオブジェクトに対して、線グラフ、棒グラフといったパーツ (レンダラ、bokehでは&lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glyphs&lt;/a&gt;と呼ぶ) を生成する&lt;/li&gt;
&lt;li&gt;(今回は格子状に図を配置したかったので）複数のfigureオブジェクトをgrid上にレイアウトする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となっています。格子状に配置しない場合は最後のステップは不要ですが、便利なので使います。&lt;/p&gt;
&lt;p&gt;グラフの更新は、レンダラに値をセットしたあとに、&lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/io.html#bokeh.io.push_notebook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bokeh.io.push_notebook&lt;/a&gt; を呼び出すことで行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class LinePlotsCallback(object):
    def __init__(self, epochs=epochs, batch_size=batch_size):
        # Epoch毎
        p1 = figure(title=&amp;quot;Loss&amp;quot;, plot_height=300, plot_width=350,
                        y_range=(0, 0.5), x_range=(-1, epochs+1))
        p2 = figure(title=&amp;quot;Acc&amp;quot;, plot_height=300, plot_width=350,
                        y_range=(0.8, 1.0), x_range=(-1, epochs+1))

        self.renderers = {&amp;quot;train&amp;quot;:{}, &amp;quot;test&amp;quot;:{}}

        # 赤: train, 青: テスト
        for phase, c in [(&amp;quot;train&amp;quot;, &amp;quot;red&amp;quot;), (&amp;quot;test&amp;quot;, &amp;quot;blue&amp;quot;)]:
            for (p, key) in [(p1, &amp;quot;loss&amp;quot;), (p2, &amp;quot;acc&amp;quot;)]:
                self.renderers[phase][key] = p.line([], [], color=c, line_width=3)

        self.graph = gridplot([p1, p2], ncols=2, toolbar_location=toolbar_location)


    def on_epoch_end(self, epoch, phase, history):
        for key in [&amp;quot;loss&amp;quot;, &amp;quot;acc&amp;quot;]:
            self.renderers[phase][key].data_source.data[&amp;quot;x&amp;quot;].append(epoch)
            self.renderers[phase][key].data_source.data[&amp;quot;y&amp;quot;].append(history[phase][key][-1])
        push_notebook()
        if save_img:
            bokeh.io.export_png(self.graph, &amp;quot;fig/{:02d}_line.png&amp;quot;.format(epoch))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;callback = LinePlotsCallback()
if show_static:
    if exists(&amp;quot;fig/line.gif&amp;quot;):
        with open(&amp;quot;fig/line.gif&amp;quot;, &#39;rb&#39;) as f:
            IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)
else:
    bokeh.io.show(callback.graph, notebook_handle=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_21_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = Net().cuda() if use_cuda else Net()
optimizer = optim.Adadelta(model.parameters())
history = train_loop(model, data_loaders, optimizer, epochs, callback=callback)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
print(&amp;quot;Test acc: {:.3f}&amp;quot;.format(history[&amp;quot;test&amp;quot;][&amp;quot;acc&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.113
Test acc: 0.990
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-vbar&#34;&gt;2. VBar&lt;/h3&gt;
&lt;p&gt;データセット全体の正解率だけでなく、カテゴリ毎の正解率などの尺度を知りたい時がよくあります。次は、数字の各カテゴリごとにどのくらい正解しているのか、といった尺度を可視化するために、縦棒グラフを作ってみます。これには、 &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/vbar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/vbar.html&lt;/a&gt; が使えます。on_epoch_endで渡されるhistoryのうち、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;カテゴリ毎の総サンプル数 (list)&lt;/li&gt;
&lt;li&gt;カテゴリ毎の正解サンプル数 (list)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の二つを使って動的にグラフを更新します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Line&lt;/code&gt; オブジェクトの更新は、&lt;code&gt;data_source.data[&amp;quot;x&amp;quot;]&lt;/code&gt;, &lt;code&gt;data_source.data[&amp;quot;y&amp;quot;]&lt;/code&gt; に値を追加していくことで行いましたが、&lt;code&gt;VBar&lt;/code&gt;オブジェクトの場合は、&lt;code&gt;data_source.data[&amp;quot;top&amp;quot;]&lt;/code&gt; に値をセットします。下向きの棒グラフが作りたい場合は、&lt;code&gt;data_source.data[&amp;quot;bottom&amp;quot;]&lt;/code&gt; に値をセットすればOKです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VBarPlotsCallback(object):
    def __init__(self, epochs=epochs, batch_size=batch_size):
        # Epoch毎
        p1 = figure(title=&amp;quot;Category-wise correctness (train)&amp;quot;,
                    plot_height=300, plot_width=350, y_range=(0, 7000))
        p2 = figure(title=&amp;quot;Category-wise correctness (test)&amp;quot;,
                    plot_height=300, plot_width=350, y_range=(0, 1500))

        self.renderers = {&amp;quot;train&amp;quot;:{}, &amp;quot;test&amp;quot;:{}}

        bar_opts = dict(width=0.8, alpha=0.5)
        for phase, p in [(&amp;quot;train&amp;quot;, p1), (&amp;quot;test&amp;quot;, p2)]:
            for (key, c) in [(&amp;quot;corrects&amp;quot;, &amp;quot;blue&amp;quot;), (&amp;quot;counts&amp;quot;, &amp;quot;red&amp;quot;)]:
                self.renderers[phase][key] = p.vbar(
                    x=np.arange(0,10), top=[0]*10, name=&amp;quot;test&amp;quot;, color=c, **bar_opts)

        self.graph = gridplot([p1, p2], ncols=2, toolbar_location=toolbar_location)

    def on_epoch_end(self, epoch, phase, history):
        for key in [&amp;quot;counts&amp;quot;, &amp;quot;corrects&amp;quot;]:
            self.renderers[phase][key].data_source.data[&amp;quot;top&amp;quot;] = history[phase][key][-1]
            push_notebook()
        if save_img:
            bokeh.io.export_png(self.graph, &amp;quot;fig/{:02d}_vbar.png&amp;quot;.format(epoch))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;callback = VBarPlotsCallback()
if show_static:
    if exists(&amp;quot;fig/vbar.gif&amp;quot;):
        with open(&amp;quot;fig/vbar.gif&amp;quot;, &#39;rb&#39;) as f:
            IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)
else:
    bokeh.io.show(callback.graph, notebook_handle=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_25_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = Net().cuda() if use_cuda else Net()
optimizer = optim.Adadelta(model.parameters())
history = train_loop(model, data_loaders, optimizer, epochs, callback=callback)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
print(&amp;quot;Test acc: {:.3f}&amp;quot;.format(history[&amp;quot;test&amp;quot;][&amp;quot;acc&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.115
Test acc: 0.989
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-hbar&#34;&gt;3. HBar&lt;/h3&gt;
&lt;p&gt;HBarと非常に似たグラフとして、横向きの棒グラフである &lt;a href=&#34;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/hbar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/hbar.html&lt;/a&gt; があります。VBarの場合と同様に、カテゴリ毎の正解サンプル数を可視化してみます。本質的に可視化する情報は変わりませんが、あくまでデモということで。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HBar&lt;/code&gt;オブジェクトの更新は、&lt;code&gt;data_source.data[&amp;quot;right&amp;quot;]&lt;/code&gt; or &lt;code&gt;data_source.data[&amp;quot;left&amp;quot;]&lt;/code&gt; に値をセットすればOKです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class HBarPlotsCallback(object):
    def __init__(self, epochs=epochs, batch_size=batch_size):
        # Epoch毎
        p1 = figure(title=&amp;quot;Category-wise correctness (train)&amp;quot;,
                    plot_height=300, plot_width=350, x_range=(0, 7000))
        p2 = figure(title=&amp;quot;Category-wise correctness (test)&amp;quot;,
                    plot_height=300, plot_width=350, x_range=(0, 1500))

        self.renderers = {&amp;quot;train&amp;quot;:{}, &amp;quot;test&amp;quot;:{}}

        bar_opts = dict(height=0.8, alpha=0.5)
        for phase, p in [(&amp;quot;train&amp;quot;, p1), (&amp;quot;test&amp;quot;, p2)]:
            for (key, c) in [(&amp;quot;corrects&amp;quot;, &amp;quot;blue&amp;quot;), (&amp;quot;counts&amp;quot;, &amp;quot;green&amp;quot;)]:
                self.renderers[phase][key] = p.hbar(
                    y=np.arange(0,10), right=[0]*10, name=&amp;quot;test&amp;quot;, color=c, **bar_opts)

        self.graph = gridplot([p1, p2], ncols=2, toolbar_location=toolbar_location)

    def on_epoch_end(self, epoch, phase, history):
        for key in [&amp;quot;counts&amp;quot;, &amp;quot;corrects&amp;quot;]:
            self.renderers[phase][key].data_source.data[&amp;quot;right&amp;quot;] = history[phase][key][-1]
            push_notebook()
        if save_img:
            bokeh.io.export_png(self.graph, &amp;quot;fig/{:02d}_hbar.png&amp;quot;.format(epoch))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;callback = HBarPlotsCallback()
if show_static:
    if exists(&amp;quot;fig/hbar.gif&amp;quot;):
        with open(&amp;quot;fig/hbar.gif&amp;quot;, &#39;rb&#39;) as f:
            IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)
else:
    bokeh.io.show(callback.graph, notebook_handle=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_29_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = Net().cuda() if use_cuda else Net()
optimizer = optim.Adadelta(model.parameters())
history = train_loop(model, data_loaders, optimizer, epochs, callback=callback)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
print(&amp;quot;Test acc: {:.3f}&amp;quot;.format(history[&amp;quot;test&amp;quot;][&amp;quot;acc&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.116
Test acc: 0.989
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-image&#34;&gt;5. Image&lt;/h3&gt;
&lt;p&gt;最後に、https://bokeh.pydata.org/en/latest/docs/reference/models/glyphs/image_rgba.html を使って、画像を可視化する例を紹介します。例えば生成モデルを学習するときなど、学習の過程で、その生成サンプルを可視化したい場合がよくあるので、そういった場合に使えます。&lt;/p&gt;
&lt;p&gt;最初に実装したモデルは手書き数字認識のための識別モデルだったため、趣向を変えて、生成モデルである Variational Auto-encoder (VAE) を使います。識別モデルの学習と生成モデルの学習は少し毛色が違うので、（ほとんど同じですが、簡単のため）併せて学習用のコードを書き換えました。&lt;/p&gt;
&lt;h4 id=&#34;vae&#34;&gt;VAE&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pytorch/examples/tree/master/vae&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/pytorch/examples/tree/master/vae&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VAE(nn.Module):
    def __init__(self):
        super(VAE, self).__init__()

        self.fc1 = nn.Linear(784, 400)
        self.fc21 = nn.Linear(400, 20)
        self.fc22 = nn.Linear(400, 20)
        self.fc3 = nn.Linear(20, 400)
        self.fc4 = nn.Linear(400, 784)

        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()

    def encode(self, x):
        h1 = self.relu(self.fc1(x))
        return self.fc21(h1), self.fc22(h1)

    def reparameterize(self, mu, logvar):
        if self.training:
            std = logvar.mul(0.5).exp_()
            eps = Variable(std.data.new(std.size()).normal_())
            return eps.mul(std).add_(mu)
        else:
            return mu

    def decode(self, z):
        h3 = self.relu(self.fc3(z))
        return self.sigmoid(self.fc4(h3))

    def forward(self, x):
        mu, logvar = self.encode(x.view(-1, 784))
        z = self.reparameterize(mu, logvar)
        return self.decode(z), mu, logvar

def loss_function(recon_x, x, mu, logvar):
    BCE = F.binary_cross_entropy(recon_x, x.view(-1, 784))

    # see Appendix B from VAE paper:
    # Kingma and Welling. Auto-Encoding Variational Bayes. ICLR, 2014
    # https://arxiv.org/abs/1312.6114
    # 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)
    KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
    # Normalise by same number of elements as in reconstruction
    KLD /= batch_size * 784

    return BCE + KLD
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;training-loop&#34;&gt;Training loop&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __train_loop_vae(model, data_loaders, optimizer, epoch, phase):
    model = model.train() if phase == &amp;quot;train&amp;quot; else model.eval()
    running_loss = 0
    recon_batch_first, target = None, None
    for batch_idx, (x, _) in enumerate(data_loaders[phase]):
        x = x.cuda() if use_cuda else x
        x = Variable(x)
        optimizer.zero_grad()
        y_hat = model(x)

        # loss
        recon_batch, mu, logvar = model(x)
        loss = loss_function(recon_batch, x, mu, logvar)

        # update
        if phase == &amp;quot;train&amp;quot;:
            loss.backward()
            optimizer.step()
        running_loss += loss.data[0]

        if target is None:
            target = x
            recon_batch_first = recon_batch

    # epoch-wise metrics
    l = running_loss / len(data_loaders[phase])
    return {&amp;quot;loss&amp;quot;: l, &amp;quot;recon&amp;quot;: recon_batch_first.data.cpu(), &amp;quot;target&amp;quot;: target.data.cpu()}

def train_loop_vae(model, data_loaders, optimizer, epochs=12, callback=None):
    history = {&amp;quot;train&amp;quot;: {}, &amp;quot;test&amp;quot;: {}}
    for epoch in tnrange(epochs):
        for phase in [&amp;quot;train&amp;quot;, &amp;quot;test&amp;quot;]:
            d = __train_loop_vae(model, data_loaders, optimizer, epoch, phase)
            for k,v in d.items():
                try:
                    history[phase][k].append(v)
                except KeyError:
                    history[phase][k] = [v]

            if callback is not None:
                callback.on_epoch_end(epoch, phase, history)
    return history
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;さて、準備は終わりです。&lt;/p&gt;
&lt;p&gt;次に示す &lt;code&gt;ImagePlotsCallback&lt;/code&gt; は、&lt;code&gt;on_epoch_end&lt;/code&gt; で学習結果のhisotoryを受け取って、VAEを通して復元した画像と、復元したい対象の画像を動的に更新します。ImageRGBA の場合は、&lt;code&gt;data_source.data[&amp;quot;image&amp;quot;]&lt;/code&gt; に配列をセットすることで、更新することができます。&lt;/p&gt;
&lt;p&gt;注意事項として、モノクロ画像を描画する際には、適当なカラーマップをかけて、(w, h) -&amp;gt; (w, h, 4) の配列にしておく必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from torchvision.utils import make_grid
from matplotlib.pyplot import cm

def _to_img(batch, cmap=cm.gray):
    # 128は多かったので半分にします
    _batch_size = batch_size // 2
    batch = batch[:_batch_size]

    batch = batch.view(-1,1,28,28)
    grid = make_grid(batch, nrow=int(np.sqrt(_batch_size)))[0].numpy()
    # Force squared
    l = np.min(grid.shape)
    grid = grid[:l, :l]
    img = np.uint8(cmap(grid) * 255)
    return img

class ImagePlotsCallback(object):
    def __init__(self, epochs=epochs, batch_size=batch_size, cmap=cm.gray):
        x_range, y_range = (-0.5, 10.5), (-0.5, 10.5)
        p1 = figure(title=&amp;quot;Reconstructed (train)&amp;quot;,
                    plot_height=350, plot_width=350, x_range=x_range, y_range=y_range)
        p2 = figure(title=&amp;quot;Target (train)&amp;quot;,
                    plot_height=350, plot_width=350, x_range=x_range, y_range=y_range)
        p3 = figure(title=&amp;quot;Reconstructed (test)&amp;quot;,
                    plot_height=350, plot_width=350, x_range=x_range, y_range=y_range)
        p4 = figure(title=&amp;quot;Target (test)&amp;quot;,
                    plot_height=350, plot_width=350, x_range=x_range, y_range=y_range)
        self.cmap = cmap

        self.renderers = {&amp;quot;train&amp;quot;:{}, &amp;quot;test&amp;quot;:{}}
        empty = torch.zeros(batch_size,1,28,28)
        empty = _to_img(empty, self.cmap)
        # to adjast aspect ratio
        r = empty.shape[0]/empty.shape[1]

        # https://github.com/bokeh/bokeh/issues/1666
        for k, p in [(&amp;quot;recon&amp;quot;, p1), (&amp;quot;target&amp;quot;, p2)]:
            self.renderers[&amp;quot;train&amp;quot;][k] = p.image_rgba(image=[empty[::-1]], x=[0], y=[0], dw=[10], dh=[r*10])
        for k, p in [(&amp;quot;recon&amp;quot;, p3), (&amp;quot;target&amp;quot;, p4)]:
            self.renderers[&amp;quot;test&amp;quot;][k] = p.image_rgba(image=[empty[::-1]], x=[0], y=[0], dw=[10], dh=[r*10])

        self.graph = gridplot([p1, p2, p3, p4], ncols=2, toolbar_location=toolbar_location)

    def on_epoch_end(self, epoch, phase, history):
        for k in [&amp;quot;recon&amp;quot;, &amp;quot;target&amp;quot;]:
            self.renderers[phase][k].data_source.data[&amp;quot;image&amp;quot;] = [_to_img(history[phase][k][-1], self.cmap)[::-1]]
        push_notebook()

        if save_img:
            bokeh.io.export_png(self.graph, &amp;quot;fig/{:02d}_{}_image.png&amp;quot;.format(epoch, self.cmap.name))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# グレースケール
callback = ImagePlotsCallback(cmap=cm.gray)
if show_static:
    if exists(&amp;quot;fig/gray_image.gif&amp;quot;):
        with open(&amp;quot;fig/gray_image.gif&amp;quot;, &#39;rb&#39;) as f:
            IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)
else:
    bokeh.io.show(callback.graph, notebook_handle=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_38_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# gifを作ったときに見やすいように、shuffle=Falseにする
kwargs = {&#39;num_workers&#39;: 1, &#39;pin_memory&#39;: True} if use_cuda else {}
train_loader = torch.utils.data.DataLoader(
    datasets.MNIST(&#39;./data&#39;, train=True, download=True,
                   transform=transforms.Compose([
                       transforms.ToTensor()
                   ])),
    batch_size=batch_size, shuffle=False, **kwargs)
test_loader = torch.utils.data.DataLoader(
    datasets.MNIST(&#39;./data&#39;, train=False, transform=transforms.Compose([
                       transforms.ToTensor(),
                   ])),
    batch_size=batch_size, shuffle=False, **kwargs)

data_loaders = {&amp;quot;train&amp;quot;: train_loader, &amp;quot;test&amp;quot;:test_loader}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = VAE().cuda() if use_cuda else VAE()
optimizer = optim.Adam(model.parameters(), lr=1e-3)
history = train_loop_vae(model, data_loaders, optimizer, epochs, callback=callback)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.133
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本質的な違いはありませんが、異なるカラーマップを試してみます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;gradient = np.linspace(0,1,256)
gradient = np.vstack((gradient, gradient))
pyplot.figure(figsize=(16,0.5))
imshow(gradient, aspect=&amp;quot;auto&amp;quot;, cmap=cm.inferno)
axis(&amp;quot;off&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_42_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;callback = ImagePlotsCallback(cmap=cm.inferno)
if show_static:
    if exists(&amp;quot;fig/inferno_image.gif&amp;quot;):
        with open(&amp;quot;fig/inferno_image.gif&amp;quot;, &#39;rb&#39;) as f:
            IPython.display.display(Image(data=f.read()), format=&amp;quot;gif&amp;quot;)
else:
    bokeh.io.show(callback.graph, notebook_handle=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://r9y9.github.io/images/jupyter_with_bokeh_files/jupyter_with_bokeh_43_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = VAE().cuda() if use_cuda else VAE()
optimizer = optim.Adam(model.parameters(), lr=1e-3)
history = train_loop_vae(model, data_loaders, optimizer, epochs, callback=callback)
print(&amp;quot;Test loss: {:.3f}&amp;quot;.format(history[&amp;quot;train&amp;quot;][&amp;quot;loss&amp;quot;][-1]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Test loss: 0.133
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;Bokehによるグラフ作成は、少しとっつきにくいかもしれませんが（matplotlibとかではレンダラとか意識しないですよね）、慣れれば柔軟性が高く、便利なのではないかと思います。&lt;/p&gt;
&lt;p&gt;今回の記事を書くにあたっては、bokeh v0.12.9 を使いました。もしローカルでnotebookを実行する場合は、バージョンを揃えることをおすすめします。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/driller/items/0730325bf5c1cd689979&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ipywidgetsとBokeh使ってインタラクティブな可視化をする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/y__sama/items/654ed8ab7464718876f9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jupyter Notebookを動的に使ってみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bokeh.pydata.org/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Welcome to Bokeh — Bokeh 0.12.12 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/r9y9/items/d54162d37ec4f110f4b4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PyTorchで学習の過程を確認したいときはtensorboardXを使うのが良かったです -　Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Juliaをソースからビルドする / Building Julia from source</title>
      <link>https://r9y9.github.io/blog/2016/12/23/julia-advent-calender-2016-customize-source-build/</link>
      <pubDate>Fri, 23 Dec 2016 18:06:08 +0900</pubDate>
      <guid>https://r9y9.github.io/blog/2016/12/23/julia-advent-calender-2016-customize-source-build/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2016/julialang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia advent calendar 2016&lt;/a&gt; 23日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;Juilaを最も簡単にインストールする方法は、&lt;a href=&#34;http://julialang.org/downloads/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式のダウンロードページ&lt;/a&gt;からバイナリ or インストーラを使用することだと思います。多くの人は、処理系をソースからビルドして使用することはめったにないと思いますが&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;、自分好みにビルドをカスタマイズしてJuliaを使いたいというコアな方向けに、僕がよく使うビルド時のオプションや便利そうなオプション、ビルド時のTipsなどを紹介しようと思います。&lt;/p&gt;
&lt;p&gt;僕がソースからビルドすることになった主な理由は、ソースからビルドしないと使えないパッケージがあったからです&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h2 id=&#34;下準備&#34;&gt;下準備&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/JuliaLang/julia &amp;amp;&amp;amp; cd julia
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ビルドのカスタマイズ方法&#34;&gt;ビルドのカスタマイズ方法&lt;/h2&gt;
&lt;p&gt;Juliaのビルドシステムでは、Make.userというファイルで、ユーザがいくらかカスタマイズすることを許可しています。プロジェクトトップにMake.userを作成し、そこに &lt;code&gt;override LLVM_VER=3.7.1&lt;/code&gt; のような書き方で記述することで、カスタマイズ可能です（詳細は&lt;a href=&#34;https://github.com/JuliaLang/julia#source-download-and-compilation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式の説明&lt;/a&gt;をご覧ください）。例えば僕の場合、主な開発環境であるmacOSではMake.userを以下のように記述しています（項目の説明は後ほどします）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;override LLVM_VER=3.7.1
override LLVM_ASSERTIONS=1
override BUILD_LLVM_CLANG=1
override USE_LLVM_SHLIB=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あとは、通常通りmakeコマンドを走らせることで、ビルドを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コア数は適当に指定します。llvm, openblasあたりのビルドが結構重いので、並列ビルドがオススメです。&lt;/p&gt;
&lt;h2 id=&#34;僕がよく使うオプション&#34;&gt;僕がよく使うオプション&lt;/h2&gt;
&lt;p&gt;ここから、僕がよく使うオプションをいくつか解説します。&lt;/p&gt;
&lt;h3 id=&#34;llvm_ver&#34;&gt;LLVM_VER&lt;/h3&gt;
&lt;p&gt;llvmのバージョンを表します。Julia上でC++を使いたいというcrazyな人に激推しの &lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Keno/Cxx.jl&lt;/a&gt; というパッケージがあるのですが、このパッケージはclangとllvmの3.7.1以上を必要とします（Cxx.jlについては、過去に何度か記事を書いたので、例えば &lt;a href=&#34;http://r9y9.github.io/blog/2016/01/24/passing-julia-expressions-to-cxx/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cxx.jlを用いてJulia expression/value をC++に埋め込む実験&lt;/a&gt; をご覧ください）。llvm 3.3がデフォルトだったJulia v0.4時代では、明示的に3.7.1と指定する必要がありました。いまは、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Julia v0.5の公式配布バイナリでも、&lt;code&gt;Pkg.add(&amp;quot;Cxx&amp;quot;)&lt;/code&gt;でインストールできるとされている（&lt;a href=&#34;https://github.com/Keno/Cxx.jl/issues/287&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Keno/Cxx.jl/#287&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;かつ現状のデフォルトバージョンが3.7.1 (もうすぐ3.9.1になりそうですが &lt;a href=&#34;https://github.com/JuliaLang/julia/pull/19678/files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JuliaLang/julia/#19768&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なので、僕の場合は明示的にLLVM_VERを指定する必要はなくなってきましたが、例えば、LLVMのNVPTX backendを使ってJuliaでCUDAカーネルを書けるようにする &lt;a href=&#34;https://github.com/JuliaGPU/CUDAnative.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JuliaGPU/CUDAnative.jl&lt;/a&gt; （要 llvm 3.9）のような、experimentalなパッケージを試したい場合など、LLVM_VERを指定したくなる場合もあるかと思います。&lt;/p&gt;
&lt;h3 id=&#34;llvm_assertions&#34;&gt;LLVM_ASSERTIONS&lt;/h3&gt;
&lt;p&gt;LLVMをassert付きでビルドするかどうかを表します。ONにするとビルドかかる時間が長くなり、LLVMのパフォーマンスが若干落ちますが、デバッグには便利です。Juliaのコード生成周りでエラーを起こしやすいようなコードを書くときには、ONにしておくと便利です。&lt;/p&gt;
&lt;h3 id=&#34;build_llvm_clang&#34;&gt;BUILD_LLVM_CLANG&lt;/h3&gt;
&lt;p&gt;llvmとあわせて、clangをビルドするかどうか、というオプションです。Cxx.jlに必要なので、僕はそのためにONにしています。その他必要なケースとしては、clangのaddress/memory sanitizerを使いたい場合が考えられます。詳細は&lt;a href=&#34;http://docs.julialang.org/en/stable/devdocs/sanitizers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;devdocs/sanitizers&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;h2 id=&#34;cc-cxx&#34;&gt;CC, CXX&lt;/h2&gt;
&lt;p&gt;コンパイラの指定です。僕の場合 ubuntu 14.04では、（Cxx.jlのために）以下のように設定しています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;override CC=gcc-6
override CXX=g++-6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://github.com/r9y9/julia-cxx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/r9y9/julia-cxx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;macOS では特に設定していませんが、Julia以外のプロジェクトをビルドするときに、たまに&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CXX=usr/local/bin/clang++ cmake ${path_to_project}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、xcode付属のclangではなく、自前でビルドしたclangを使いたい場合などに、CC, CXXを指定したりします。&lt;/p&gt;
&lt;h3 id=&#34;use_clang&#34;&gt;USE_CLANG&lt;/h3&gt;
&lt;p&gt;clangを使ってビルドするかどうかを表します。gccを使いたくない、というときにオンにします。&lt;/p&gt;
&lt;h3 id=&#34;use_llvm_shlib&#34;&gt;USE_LLVM_SHLIB&lt;/h3&gt;
&lt;p&gt;llvmを共有ライブラリとしてビルドするかどうかを表します。v0.4ではデフォルトがオフで、v0.5からはオンになっています。llvmの共有ライブラリをdlopenして色々いじりたい場合（何度もアレですが、Cxx.jlを使いたい場合とか）は、オンにする必要があります。&lt;/p&gt;
&lt;h3 id=&#34;use_system_lib_name&#34;&gt;USE_SYSTEM_${LIB_NAME}&lt;/h3&gt;
&lt;p&gt;Juliaでは、デフォルトで依存ライブラリをソースからビルドします。システムにインストールされたライブラリを使用したい場合、USE_SYSTEM_XXX （e.g. &lt;code&gt;USE_SYSTEM_BLAS&lt;/code&gt;）をオンにします。ビルド時間を短縮することが可能です。&lt;/p&gt;
&lt;p&gt;USE_SYSTEM_xxx にどのようなものがあるのかは、&lt;a href=&#34;https://github.com/JuliaLang/julia/blob/d8ecebe1a47fd401ef63a80250c096a21843a82d/Make.inc#L25-L47&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Make.inc&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;h2 id=&#34;便利そうなオプション&#34;&gt;便利そうなオプション&lt;/h2&gt;
&lt;h3 id=&#34;use_intel_mkl&#34;&gt;USE_INTEL_MKL&lt;/h3&gt;
&lt;p&gt;MKLを使うかどうかを表します。MKLを持っている場合にオンにすれば、一部パフォーマンスが向上しそうですね。&lt;/p&gt;
&lt;h3 id=&#34;use_gpl_libs&#34;&gt;USE_GPL_LIBS&lt;/h3&gt;
&lt;p&gt;GPLのライブラリ（FFTWなど）を使用するかどうかを表します。使ったことはありませんが、Juliaを組み込みで使用したい場合に、便利かもしれません。&lt;/p&gt;
&lt;h2 id=&#34;ビルド時のtips&#34;&gt;ビルド時のTips&lt;/h2&gt;
&lt;p&gt;Juliaは依存関係が多く、cloneした直後の状態からのビルドには一時間以上かかることもあります&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。また、masterを追いかけている場合は、途中でビルドにこけてしまうことも珍しくありません。個人的な経験で言えば、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;llvm&lt;/li&gt;
&lt;li&gt;openblas&lt;/li&gt;
&lt;li&gt;libgit2&lt;/li&gt;
&lt;li&gt;mbettls&lt;/li&gt;
&lt;li&gt;libunwind&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あたりの依存関係のビルドで、何度も失敗しています。僕がソースビルドをし始めたころ、よく調べずに &lt;code&gt;make clean &amp;amp;&amp;amp; make&lt;/code&gt; をして、案の定駄目で、よくわからずに &lt;code&gt;make distcleannall&lt;/code&gt; してしまうこともありました（&lt;code&gt;distcleanall&lt;/code&gt;が必要なケースは稀であり、そうでない場合は非常に時間を無駄にします）&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。過去の失敗から、僕が学んできたTipsを紹介します。&lt;/p&gt;
&lt;h3 id=&#34;プロジェクトトップmakefileのcleanコマンドを適切に使い分ける&#34;&gt;プロジェクトトップMakefileのcleanコマンドを適切に使い分ける&lt;/h3&gt;
&lt;p&gt;cleanコマンドにはさまざまなものがあります。ビルドのし直しが不要なものまでcleanして、無駄に時間を消費しないように、正しく使い分けましょう。以下、基本的なcleanコマンドを簡単にまとめます。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コマンド&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;clean&lt;/td&gt;
&lt;td&gt;Julia本体のclean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cleanall&lt;/td&gt;
&lt;td&gt;Julia本体、flisp、libuvのclean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;distclean&lt;/td&gt;
&lt;td&gt;binary配布用の成果物をclean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;distcleanall&lt;/td&gt;
&lt;td&gt;deps以下の依存関係をすべてclean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;よほどのことがない限り、 &lt;code&gt;make distcleanall&lt;/code&gt; を使わないようにしましょう。&lt;code&gt;make distclean&lt;/code&gt; はほとんど使う必要はないと思います。&lt;/p&gt;
&lt;p&gt;コマンドの詳細、その他コマンドについては、&lt;a href=&#34;https://github.com/JuliaLang/julia/blob/d8ecebe1a47fd401ef63a80250c096a21843a82d/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia/Makefile&lt;/a&gt; をご覧ください&lt;/p&gt;
&lt;h3 id=&#34;サブディレクトリのmakefileを使いわける&#34;&gt;サブディレクトリのMakefileを使いわける&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;deps&lt;/strong&gt;: 依存関係&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;src&lt;/strong&gt;: コンパイラ (C, C++, flisp)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;base&lt;/strong&gt;: 標準ライブラリ (Julia)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;doc&lt;/strong&gt;: ドキュメント&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;など（一部です）、Makefileは復数のサブディレクトリにわかれています。依存関係のビルドに失敗した場合には、depsディレクトリ以下のMakefileが使えます。&lt;/p&gt;
&lt;p&gt;depsディレクトリ以下、依存関係のcleanコマンドには、大きく以下の二種類があります。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コマンド&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;clean-xxx&lt;/td&gt;
&lt;td&gt;xxx の clean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;distclean-xxx&lt;/td&gt;
&lt;td&gt;xxx の clean と &lt;code&gt;rm -rf ビルドディレクトリ&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例えばlibgit2のバージョンが変わってエラーが出たからといって、すべてをビルドし直す必要は基本的にはありません。まずは、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -C deps clean-libgit2 &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;としてビルドし直し、それでも駄目な場合は、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make -C deps distclean-libgit2 &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といった具合に、軽いcleanコマンドから順に試しましょう。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Make.user をプロジェクトトップに配置することで、ビルドをカスタマイズできます&lt;/li&gt;
&lt;li&gt;ビルドに失敗したとき、良く考えずに &lt;code&gt;make distcleanall&lt;/code&gt; するのをやめましょう（自戒&lt;/li&gt;
&lt;li&gt;サブディレクトリの Makefile を使い分けて、rebuildは最小限にしましょう&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;大変ですよね&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/Keno/Cxx.jl&lt;/a&gt; です&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;環境によります&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;僕があほなだけの可能性が大いにあります&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Cxx.jl を使ってみた感想 &#43; OpenCV.jl, Libfreenect2.jl の紹介</title>
      <link>https://r9y9.github.io/blog/2015/12/22/cxx-jl/</link>
      <pubDate>Tue, 22 Dec 2015 00:00:00 +0000</pubDate>
      <guid>https://r9y9.github.io/blog/2015/12/22/cxx-jl/</guid>
      <description>&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://r9y9.github.io/images/opencvjl_demo.jpg &#34;OpenCV.jl based on Cxx.jl&#34;&#34; class=&#34;image&#34;&gt;&lt;/div&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2015/julialang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Advent Calendar 2015&lt;/a&gt; 22日目の記事です。&lt;/p&gt;
&lt;p&gt;Julia の C++ FFI (Foreign Function Interface) である &lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cxx.jl&lt;/a&gt; をしばらく使ってみたので、その感想を書きます。加えて、Cxx.jl を使って作った成果物の話も簡単に書こうと思います（冒頭に貼った画像は、OpenCV.jl でテキトーにカメラから画像をキャプチャしてthresholdingしたやつです）。
Cxx.jl の動作原理については、僕の理解が不十分なため簡単にしか紹介できませんが、そもそも使ったことがある人が稀だと思われるので、感想程度でも役に立てば幸いです。&lt;/p&gt;
&lt;h2 id=&#34;cxxjl-とは&#34;&gt;Cxx.jl とは&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Keno/Cxx.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/Keno/Cxx.jl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;簡単に説明すると、Cxx.jl とは、Julia から C++ を使用する（e.g. 関数呼び出し、メソッド呼び出し、メンバ変数へのアクセス、etc) ための機能を提供するパッケージです。C++のライブラリを活用したい、あるいはパフォーマンスがシビアな箇所で一部 C++ 使いたい（Cインタフェースを作りたくない&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;）、といった場合に便利です。&lt;/p&gt;
&lt;p&gt;Cxx.jl の原理についてざっくりといえば、clang を用いて C++ から LLVM IR を生成し、llvmcall を用いて（Just in time に）コードを実行する、という方式のようです&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Cxx.jl の原理について知りたい場合は、Cxx.jl のソースコード（+コメント）を、Cxx.jl を使うと何ができるのか知りたい場合は、Cxx.jl の README を御覧ください。&lt;/p&gt;
&lt;p&gt;以下、過去を思い出しながら感想を書いてみます&lt;/p&gt;
&lt;h2 id=&#34;実際に使う前に&#34;&gt;実際に使う前に&lt;/h2&gt;
&lt;h3 id=&#34;pkgbuildcxx-を成功させることが困難&#34;&gt;Pkg.build(&amp;ldquo;Cxx&amp;rdquo;) を成功させることが困難&lt;/h3&gt;
&lt;p&gt;そもそも使いはじめる前に、ビルドすることが困難でした。Cxx.jl を動作させるためには、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;julia&lt;/li&gt;
&lt;li&gt;llvm&lt;/li&gt;
&lt;li&gt;clang&lt;/li&gt;
&lt;li&gt;lldb&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の開発版が必要ですが、ビルドが難しい大きな原因は、動作することが保証された&lt;strong&gt;明確な revision が存在しない&lt;/strong&gt;ことにあります。（なんじゃそれ、と思うかもしれませんが、まぁまだ安定版はリリースされていないので、、）&lt;/p&gt;
&lt;p&gt;今でこそ、llvm, clang, lldbは、Keno氏の fork の kf/gallium ブランチ使えばいいよと README に書いてありますが、僕が使い始めた二ヶ月ほど前は、開発版のllvmが必要だよ、くらいにしか書いていませんでした（参考: &lt;a href=&#34;https://github.com/Keno/Cxx.jl/blob/3897e8720b683fe35e407f2128d14e41cec8e0dd/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cxx.jl/README&lt;/a&gt;）。何度もllvmをビルドし直すのは、本当に苦行でした…&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;今日だけでllvmをn回ビルドしてる（ビルドできたとは言ってない&lt;/p&gt;&amp;mdash; 山本りゅういち (@r9y9) &lt;a href=&#34;https://twitter.com/r9y9/status/655000313112367104&#34;&gt;October 16, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;br&gt;
&lt;p&gt;思考停止の様子：&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;make -C deps clean-llvm &amp;amp; make -j4&lt;/p&gt;&amp;mdash; 山本りゅういち (@r9y9) &lt;a href=&#34;https://twitter.com/r9y9/status/670571501658251264&#34;&gt;November 28, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;br&gt;
&lt;h3 id=&#34;cxxjl-のビルドはどうするのが一番簡単なのか&#34;&gt;Cxx.jl のビルドはどうするのが一番簡単なのか&lt;/h3&gt;
&lt;p&gt;さて、さらっと書きましたが、今では llvm, clang, lldb　のkf/gallium　ブランチを使えば、比較的簡単に、多少の試行錯誤&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; で Cxx.jl をビルドして使えます。&lt;/p&gt;
&lt;h3 id=&#34;開発版-llvm-と一緒に-julia-をビルドする&#34;&gt;開発版 llvm と一緒に Julia をビルドする&lt;/h3&gt;
&lt;p&gt;Juliaをクローンしたディレクトリで、以下の様な &lt;code&gt;Make.user&lt;/code&gt; ファイルを作成して make します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;override LLDB_VER=master
override LLVM_VER=svn
override LLVM_ASSERTIONS=1
override BUILD_LLVM_CLANG=1
override BUILD_LLDB=1
override USE_LLVM_SHLIB=1
override LLDB_DISABLE_PYTHON=1

override LLVM_GIT_URL_LLVM=https://github.com/JuliaLang/llvm.git
override LLVM_GIT_URL_LLDB=https://github.com/JuliaLang/lldb.git
override LLVM_GIT_URL_CLANG=https://github.com/JuliaLang/clang.git
override LLVM_GIT_VER=kf/gallium
override LLVM_GIT_VER_LLDB=kf/gallium
override LLVM_GIT_VER_CLANG=kf/gallium
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一部、LLVM_ASSERSONS を有効にするなど、必ずしも必須でないものも含まれていますが、こちらが現状の推奨のようです。この設定で、僕はubuntu 14.04, osx 10.10 でビルドが通ることを確認しました&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;注意：すでに llvm や clang がローカルにクローン済の場合、&lt;code&gt;deps/srccache&lt;/code&gt; 以下からクローン済みのソースを消してからビルドすることをおすすめします。すでにクローンされていて、upstream  の変更を取り入れたい場合は、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -C deps update-llvm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とすると便利です。&lt;/p&gt;
&lt;h3 id=&#34;cxxjl-のインストール&#34;&gt;Cxx.jl のインストール&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;Pkg.clone(&amp;quot;https://github.com/Keno/Cxx.jl.git&amp;quot;)
Pkg.build(&amp;quot;Cxx&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;エラーがでなければ、インストール完了&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;です。&lt;/p&gt;
&lt;h2 id=&#34;実際に使ってみたあと&#34;&gt;実際に使ってみたあと&lt;/h2&gt;
&lt;p&gt;さて、ようやくビルドもできて、ここからは使ってしばらくしての感想です。&lt;/p&gt;
&lt;h3 id=&#34;julia-上で-c-の-syntax-がそのまま使える&#34;&gt;Julia 上で C++ の syntax がそのまま使える&lt;/h3&gt;
&lt;p&gt;まず、簡単に Cxx.jl の機能を挙げると、重要なのは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cxx&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;icxx&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@cxx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の三つです。以下、簡単に例をあげると、&lt;code&gt;cxx&amp;quot;...&amp;quot;&lt;/code&gt; でC++ syntax を評価して：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxx&amp;quot;#include &amp;lt;iostream&amp;gt;&amp;quot;

cxx&amp;quot;&amp;quot;&amp;quot;
namespace test {
void f() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello C++&amp;quot; &amp;lt;&amp;lt; std::endl;
}
}
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@cxx&lt;/code&gt; マクロで C++ 関数を呼び出す：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;@cxx test::f()  # Hello C++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cxx&amp;quot;...&amp;quot;&lt;/code&gt;はグローバルスコープで評価されますが、&lt;code&gt;icxx&amp;quot;...&amp;quot;&lt;/code&gt; を使えば、特定のスコープ内で C++ を使用することもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;for i in 1:10
    icxx&amp;quot;&amp;quot;&amp;quot;std::cout &amp;lt;&amp;lt; $i &amp;lt;&amp;lt; std::endl;&amp;quot;&amp;quot;&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ccall&lt;/code&gt; のように、返り値、引数の型などを指定して実行するのではなく、C++ のsyntax をそのまま使ってコードが書ける、という点にびっくりしました。&lt;/p&gt;
&lt;h3 id=&#34;template-も使える&#34;&gt;template も使える&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxx&amp;quot;&amp;quot;&amp;quot;
template &amp;lt;typename T&amp;gt;
T add(T x, T y) { return x + y; }
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんな感じで特殊化も可能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxx&amp;quot;&amp;quot;&amp;quot;
template &amp;lt;&amp;gt;
int add&amp;lt;int&amp;gt;(int x, int y) { return x + y; }
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;書いてて気付きましたが、README には template について言及されていませんね。僕は、今のところ問題なく使えています。例には出していませんが、template class ももちろん使えます（例. &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt;）。&lt;/p&gt;
&lt;h3 id=&#34;その他雑記&#34;&gt;その他雑記&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Cxx.jl で使える C++ には制約がある（はず）だが、ここ二ヶ月使用した限りでは、大きな制約に出会ってないし、快適&lt;/li&gt;
&lt;li&gt;共有ライブラリの呼び出しは、&lt;code&gt;ccall&lt;/code&gt; と違ってライブラリだけでなくヘッダーファイルも必要&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using Cxx&lt;/code&gt; にはけっこう時間がかかる。僕の環境では約15秒だった&lt;/li&gt;
&lt;li&gt;たまに llvm error を吐いて落ちる。デバッグするには llvm, clang についてある程度知識がないと難しそう&lt;/li&gt;
&lt;li&gt;C++ REPL 便利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という感じですかね。書き進むに連れて適当になってすいません、、、&lt;/p&gt;
&lt;h2 id=&#34;cxxjl-を使って作った成果物&#34;&gt;Cxx.jl を使って作った成果物&lt;/h2&gt;
&lt;p&gt;まとめに入る前に、Cxx.jl を使って遊ぶ過程で作った成果物を、簡単なコメント付きで紹介します。&lt;/p&gt;
&lt;h3 id=&#34;opencvjl&#34;&gt;OpenCV.jl&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://r9y9.github.io/images/video_thresholding.gif &#34;OpenCV.jl demo&#34;&#34; class=&#34;image&#34;&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/r9y9/OpenCV.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/r9y9/OpenCV.jl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cxx.jl の学習の題材として作りました。途中から cv::Mat 周りを真面目に作り始めたので、それなりに使えると思います。&lt;/p&gt;
&lt;p&gt;デザインポリシーとして、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cv::Mat を &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; の subtype として Julia ライクに使えること&lt;/li&gt;
&lt;li&gt;cv::Mat と Julia の Array の相互変換をサポートすること&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を念頭において作りました。&lt;/p&gt;
&lt;h3 id=&#34;libfreenect2jl&#34;&gt;LibFreenect2.jl&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://r9y9.github.io/images/depth_streaming_example.gif &#34;LibFreenect2.jl demo&#34;&#34; class=&#34;image&#34;&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/r9y9/LibFreenect2.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/r9y9/LibFreenect2.jl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ちょうど仕事で kinect v2 を触っていたので、遊びがてらやってみました。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cxx.jl をビルドするのはけっこう面倒ですが、C++を（主観ですが）ほとんど不自由なくJITライクに使えるので、非常に便利です&lt;/li&gt;
&lt;li&gt;二つほど C++ ライブラリのラッパーを作ってみましたが、簡単にできるので、みなさんもお試しあれ&lt;/li&gt;
&lt;li&gt;レッツ・トライ Cxx.jl！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;おまけ&#34;&gt;おまけ&lt;/h2&gt;
&lt;p&gt;現在 Julia community では、llvm 3.3 から llvm 3.7.1 に移行しようとする動きがあるので（ref: &lt;a href=&#34;https://github.com/JuliaLang/julia/issues/9336&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia/issues/9336&lt;/a&gt;, &lt;a href=&#34;https://github.com/JuliaLang/julia/pull/14430&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;julia/pull/14430&lt;/a&gt;）、移行後は、もう少しビルドが楽になるかもしれません。&lt;/p&gt;
&lt;p&gt;実は、この記事を読んでも、きっと今は　Cxx.jl をビルドできないんじゃないかなと思うんですが、もしどうしてもビルドしたい、ということであれば、僕のローカルの llvm, clang, lldb, julia の revision を調べて教えるので、言ってください。&lt;/p&gt;
&lt;h3 id=&#34;20151228-追記&#34;&gt;2015/12/28 追記&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://qiita.com/r9y9/items/37633ed37e22612b5224&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cxx.jl を動作させるための julia, llvm, clang, lldb のコミットハッシュ | qiita&lt;/a&gt;&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;例えば template を多用している場合、Cインタフェースを作るのは面倒です&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;※正確に理解していないため、あまり宛てにしないでください）&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;多少の試行錯誤、というのは、Julia と Cxx.jl のリビジョンは、経験的には必ずしも（特にJuliaの）masterで動作しないので、Julia と Cxx.jl を master から少し遡って、ビルドできるか試行錯誤する、という意味です&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;ビルドが通ったことがある、の方が正確ですが&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;なお、現状のJulia masterとCxx.jl masterでは、エラーが出ると踏んでおります、、、&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Julia: 値と変数に対する Type Annotation の違い</title>
      <link>https://r9y9.github.io/blog/2015/12/08/julia-type-annotations/</link>
      <pubDate>Tue, 08 Dec 2015 00:00:00 +0000</pubDate>
      <guid>https://r9y9.github.io/blog/2015/12/08/julia-type-annotations/</guid>
      <description>&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2015/julialang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Advent Calendar 2015&lt;/a&gt; 8日目の記事です。&lt;/p&gt;
&lt;p&gt;この記事では、値 (value) と変数 (variable) に対する type annotation の違いを、問題とそれに対する解答を用意する形式で説明しようと思います。そんなの知ってるぜ！という方は、問題だけ解いてみて自分の理解度を試してもらえればと思います。&lt;/p&gt;
&lt;p&gt;記事に出てくるJuliaコードは、Julia 0.5-dev, 0.4.0 で動作確認しました。&lt;/p&gt;
&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;
&lt;p&gt;新規REPLセッションを開いて、A、B それぞれを実行したときの挙動はどうなるでしょうか？エラーの発生の有無と、エラーが発生しない場合は返り値の値、型を答えてください。&lt;/p&gt;
&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;function f()
    x = (1.0 + 2.0)::Int
    return x
end

f()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;function g()
    x::Int = (1.0 + 2.0)
    return x
end

g()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なお、一方ではエラーが起き、もう一方はエラー無く実行されます。一見似たような書き方ですが、二つは異なる意味を持ちます。この記事ではそれぞれを解説しようと思います。&lt;/p&gt;
&lt;p&gt;この問題の答えがわからなかった方は、この記事を読むと正解がわかるはずなので、続きをご覧ください。下の方に、簡潔な問題の解答とおまけ問題を書いておきました。&lt;/p&gt;
&lt;h2 id=&#34;a-値に対する-type-annotation&#34;&gt;A: 値に対する type annotation&lt;/h2&gt;
&lt;p&gt;Aの2行目では、値に対して type annotation をしています。これは typeassert とも呼びます。Aで使った type annotation を日本語で説明してみると、「&lt;code&gt;(1.0 + 2.0)&lt;/code&gt; という式を評価した値は、Int 型であることを保証する」となります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(1.0 + 2.0)&lt;/code&gt; を評価した値は &lt;code&gt;3.0&lt;/code&gt; であり、 Float64の型を持ちます。したがって &lt;code&gt;Float64 != Int&lt;/code&gt; であるため、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR: TypeError: typeassert: expected Int64, got Float64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のような typeassert のエラーが吐かれます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(1.0 + 2.0)&lt;/code&gt;を評価した値の型は一見して明らかため、実用的な例ではありませんが、例えば関数の返り値の型は一見してわからないことがあるので、例えば以下のような書き方は有用な場合もあると思います。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;x = f(y)::Int
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;b-変数に対する-type-annotation&#34;&gt;B: 変数に対する type annotation&lt;/h2&gt;
&lt;p&gt;Bの2行目では、変数に対して type annotation をしています。同じく日本語で説明すると、「&lt;code&gt;x&lt;/code&gt;という変数に入る値は、Int 型であることを保証する」となります。また、値に対する annotation とは異なり&lt;strong&gt;スコープ&lt;/strong&gt;を持ちます。&lt;/p&gt;
&lt;p&gt;前述したとおり、&lt;code&gt;(1.0 + 2.0)&lt;/code&gt; を評価した値は &lt;code&gt;3.0&lt;/code&gt; であり、Float64の型を持ちます。一方で、&lt;code&gt;x&lt;/code&gt; は Int型の値を持つ変数として宣言されているため、この場合、Float64型である &lt;code&gt;(1.0 + 2.0)&lt;/code&gt; を、Int 型に変換するような処理が&lt;strong&gt;暗黙的に&lt;/strong&gt;行われます。したがって、変換可能な場合には（B の例がそうです）、エラーは起きません。暗黙的に処理が行われるというのは、知らないと予期せぬバグに遭遇することになるため、気をつける必要があります。&lt;/p&gt;
&lt;p&gt;では、変数に対する type annotation はどのような場合に使うかというと、あるスコープの範囲で、代入によって変数の型が変わってしまうのを防ぐために使います。ある変数の型がスコープの範囲で不変というのはコンパイラにとっては嬉しい事で、パフォーマンスの向上に繋がります。Performance tips にもありますね（参考: &lt;a href=&#34;http://docs.julialang.org/en/release-0.4/manual/performance-tips/#avoid-changing-the-type-of-a-variable&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Performance tips / Avoid changing the type of a variable&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;違いまとめ&#34;&gt;違いまとめ&lt;/h2&gt;
&lt;p&gt;ここまでの話から、違いをまとめると、以下のようになります。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type annotation の種類&lt;/th&gt;
&lt;th&gt;typeassert error　&lt;/th&gt;
&lt;th&gt;暗黙的な型変換　&lt;/th&gt;
&lt;th&gt;スコープ　&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;値に対する type annotation&lt;/td&gt;
&lt;td&gt;あり&lt;/td&gt;
&lt;td&gt;なし&lt;/td&gt;
&lt;td&gt;なし&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;変数に対する type annotation 　&lt;/td&gt;
&lt;td&gt;なし&lt;/td&gt;
&lt;td&gt;あり&lt;/td&gt;
&lt;td&gt;あり&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;type annotation を使うときは、値と変数に対する annotation の違いを意識して、使い分けましょう&lt;/p&gt;
&lt;h2 id=&#34;問題の解答&#34;&gt;問題の解答&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A: typeassert に引っかかり、TypeError が吐かれる&lt;/li&gt;
&lt;li&gt;B: Int 型の 3 が返り値として得られる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;おまけ問題&#34;&gt;おまけ問題&lt;/h2&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;function h()
    x::UInt8 = UInt8(0)
    x = Float64(0.0)
    x
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;# なんと表示されるでしょうか？
println(typeof(h()))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;function s()
    x::Int = Float64(0)
    x = UInt8(0)
    x = Float32(0.5)
    x
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jl&#34;&gt;# なんと表示されるでしょうか？
s()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解答は、各自REPLで実行して確認してみてください。長々と読んでくださりありがとうございました。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.julialang.org/en/release-0.4/manual/types/?highlight=typeassert#type-declarations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公式ドキュメント / Type Declarations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ccallにおけるポインタ周りのハマりどころとその解決法</title>
      <link>https://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips/</link>
      <pubDate>Tue, 09 Dec 2014 00:00:00 +0000</pubDate>
      <guid>https://r9y9.github.io/blog/2014/12/09/julia-advent-calender-2014-poiner-tips/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2014/julialang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Julia Advent Calendar 2014&lt;/a&gt; 9日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;CやFortranの関数をJuliaから呼ぶために使用する&lt;code&gt;ccall&lt;/code&gt;において、ポインタに関係するハマりどころとその解決法を紹介します。純粋なJuliaを使っている場合にはポインタを意識することはめったにないと思うので、&lt;code&gt;ccall&lt;/code&gt; を使う人（計算が重いボトルネック部分をCで書いてJuliaから呼びたい人、Cのライブラリのラッパーを書きたい/書いてる人）を主な読者と想定して記事を書きました（限定的でごめんなさい）。&lt;/p&gt;
&lt;p&gt;困った時は、公式ドキュメントの &lt;a href=&#34;http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calling C and Fortran Code&lt;/a&gt; を参考にしましょう。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 最新版の公式ドキュメントをいくつか引用していますが、ドキュメントは日々更新されていますので、この記事を読んで頂いた時点とは異なる可能性があることにご注意ください。&lt;/p&gt;
&lt;h2 id=&#34;こんなとき&#34;&gt;こんなとき&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ccall&lt;/code&gt; を使う際に、ポインタに関する以下のような疑問を持つことがあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ポインタを引数に持つ（例. &lt;code&gt;double*&lt;/code&gt;）関数のラッピングはどうすればいいのか？&lt;/li&gt;
&lt;li&gt;構造体のポインタを引数に持つ関数のラッピングはどうすれば？&lt;/li&gt;
&lt;li&gt;ポインタのポインタを引数に持つ（例. &lt;code&gt;double**&lt;/code&gt;）関数のラッピングは？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一つ目は非常に簡単で、&lt;code&gt;Array&lt;/code&gt;（Cの関数が&lt;code&gt;double*&lt;/code&gt;を取るならば&lt;code&gt;Array{Float64,1}&lt;/code&gt;）をそのまま渡せばよいだけです。ドキュメントの&lt;a href=&#34;http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/#array-conversions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Array Conversions&lt;/a&gt;にも書かれています。が、残りの二つに関してはハマりどころがあります。順に説明します。&lt;/p&gt;
&lt;h2 id=&#34;構造体のポインタを引数に持つ関数のラッピングはどうすれば&#34;&gt;構造体のポインタを引数に持つ関数のラッピングはどうすれば？&lt;/h2&gt;
&lt;p&gt;現状のドキュメントは少し不親切なので、引用した上で、整理します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.julialang.org/en/latest/manual/calling-c-and-fortran-code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calling C and Fortran Code&lt;/a&gt; より引用:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Currently, it is not possible to pass structs and other non-primitive types from Julia to C libraries. However, C functions that generate and use opaque struct types by passing pointers to them can return such values to Julia as Ptr{Void}, which can then be passed to other C functions as Ptr{Void}. Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;冒頭に it is not possible とあります。が、決して不可能なわけではありません。上記文章の要点をまとめると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opaqueな構造体はCからJuliaへポインタとして渡すことができる&lt;/li&gt;
&lt;li&gt;そのポインタは &lt;code&gt;Ptr{Void}&lt;/code&gt; としてCの関数に渡すことができる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と書かれています。つまり、一般には構造体は渡せないけどポインタ渡しはできるよ、ということです。&lt;/p&gt;
&lt;p&gt;じゃあnon-opaqueな構造体についてはどうなんだ？Juliaの型を渡せないのか？という疑問が出てきます。結論からいえば、non-opaqueな構造体についてもポインタ渡しは可能です。つまり、Cの構造体に相当するimmutableな型&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;をjuliaで宣言してあげれば、juliaの型をCに渡すことが可能です（値渡しはできません）&lt;/p&gt;
&lt;p&gt;例を示します。&lt;/p&gt;
&lt;h3 id=&#34;cコード&#34;&gt;Cコード&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
   double a;
   int b;
} Foo;

# 構造体のポインタを引数にとる関数1
void print(Foo* foo) {
    printf(&amp;quot;a=%lf\n&amp;quot;, foo-&amp;gt;a);
    printf(&amp;quot;b=%d\n&amp;quot;, foo-&amp;gt;b);
}

# 構造体のポインタを引数にとる関数2
void reset(Foo* foo) {
    foo-&amp;gt;a = 0.0;
    foo-&amp;gt;b = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;juliaコード&#34;&gt;Juliaコード&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Cの構造体 Foo に相当する型を宣言します
immutable Foo
    a::Float64
    b::Int32 # cのintはjuliaのInt32に対応します
end

foo = Foo(10.0, 2)

# Cの関数に、ポインタとしてJuliaの型を渡すことができます
ccall(:print, &amp;quot;libfoo&amp;quot;, Void, (Ptr{Foo},), &amp;amp;foo)

# ポインタで渡す場合、Cで変更した結果はJuliaにも反映されます
ccall(:reset, &amp;quot;libfoo&amp;quot;, Void, (Ptr{Foo},), &amp;amp;foo)

# foo(0.0, 0) と表示される
println(foo)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちなみにJuliaからCへ値渡しをしてもエラーにならないので、お気をつけください（ハマりました）。&lt;/p&gt;
&lt;p&gt;公式ドキュメントは不親切と言いましたが、 プルリクエスト &lt;a href=&#34;https://github.com/JuliaLang/julia/pull/8948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;update documentation for passing struct pointers to C #8948&lt;/a&gt;（まだマージはされていない）で改善されているので、もしかするとこの記事が読まれる頃には改善されているかもしれません。&lt;/p&gt;
&lt;p&gt;また、値渡しを可能にしようとする動きもあります（&lt;a href=&#34;https://github.com/JuliaLang/julia/pull/3466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC: Make struct passing work properly #3466&lt;/a&gt;, &lt;a href=&#34;https://github.com/JuliaLang/julia/pull/2818&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WIP: types as C-structs #2818&lt;/a&gt; マージ待ち）。&lt;/p&gt;
&lt;h3 id=&#34;構造体渡しのまとめ&#34;&gt;構造体渡しのまとめ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Cの構造体に相当するJuliaの型を定義して、ポインタで渡せばOK&lt;/li&gt;
&lt;li&gt;値渡しは現状できない&lt;/li&gt;
&lt;li&gt;ポインタを受けることはできる（Ptr{Void}として受ける）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ポインタのポインタを引数に持つ例-double関数のラッピングは&#34;&gt;ポインタのポインタを引数に持つ（例. &lt;code&gt;double**&lt;/code&gt;）関数のラッピングは？&lt;/h2&gt;
&lt;p&gt;さて、これはドキュメントにまったく書かれておらず、かつハマりやすいと僕は思っています。例を交えつつ解説します。以下のような関数のラッピングを考えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void fooo(double** input, int w, int h, double** output);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;は入力の行列、&lt;code&gt;output&lt;/code&gt;は計算結果が格納される行列、行列のサイズは共に 列数&lt;code&gt;w&lt;/code&gt;、行数&lt;code&gt;h&lt;/code&gt; だと思ってください。Juliaからは &lt;code&gt;input::Array{Float64,2}&lt;/code&gt; を入力として、&lt;code&gt;output::Array{Float64,2}&lt;/code&gt; を得たいとします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double*&lt;/code&gt;を引数にとる場合は&lt;code&gt;Array{Float64,1}&lt;/code&gt;を渡せばよかったのに対して、&lt;code&gt;double**&lt;/code&gt;を引数に取る関数に &lt;code&gt;Array{Float64,2}&lt;/code&gt;や&lt;code&gt;Array{Array{Float64,1},1}&lt;/code&gt;を単純に渡すだけでは、残念ながらコンパイルエラーになります。はい、すでに若干面倒ですね。。さて、どうすればいいかですが、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どんな型で渡せばいいか&lt;/li&gt;
&lt;li&gt;どのように型を変換するか&lt;/li&gt;
&lt;li&gt;変換した型をどのように元に戻すか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という三点に分けて説明します。&lt;/p&gt;
&lt;h3 id=&#34;1-どんな型で渡せばいいか&#34;&gt;1. どんな型で渡せばいいか&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Array{Ptr{Float64}}&lt;/code&gt; で渡せばよいです。外側のArrayは、&lt;code&gt;ccall&lt;/code&gt; がポインタに変換してくれるので、Juliaの型でいえば&lt;code&gt;Ptr{Ptr{Float64}}&lt;/code&gt;、Cの型で言えば&lt;code&gt;double**&lt;/code&gt;になるわけです。&lt;/p&gt;
&lt;h3 id=&#34;2-どのように型を変換するか&#34;&gt;2. どのように型を変換するか&lt;/h3&gt;
&lt;p&gt;ここがハマりどころです。今回の例では、&lt;code&gt;Array{Float64,2}&lt;/code&gt; を &lt;code&gt;Array{Ptr{Float64},1}&lt;/code&gt; に変換すればよいので、例えば以下のような実装が思いつきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Array{T,2} -&amp;gt; Array{Ptr{T}}
function ptrarray2d{T&amp;lt;:Real}(src::Array{T,2})
    dst = Array{Ptr{T}, size(src, 2))
    for i=1:size(src, 2)
        dst[i] = pointer(src[:,i], 1) # 先頭要素のポインタを取り出す
    end
    dst
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実はこの実装はバグを含んでいます。バグがあるとしたら一行しか該当する部分はないですが、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;dst[i] = pointer(src[:,i], 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここが間違っています。何が間違っているかというと、&lt;code&gt;pointer(src[:,i], 1)&lt;/code&gt;は一見&lt;code&gt;src&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;列目の先頭要素のポインタを指しているような気がしますが、&lt;code&gt;src[:,1]&lt;/code&gt;で &lt;code&gt;getindex&lt;/code&gt;という関数が走って内部データのコピーを行っているので、そのコピーに対するポインタを指している（元データの&lt;code&gt;i&lt;/code&gt;列目のポインタを指していない）点が間違っています&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。これは、JuliaのArray実装ついて多少知らないとわからないと思うので、ハマりどころと書きました。&lt;/p&gt;
&lt;p&gt;Array &lt;code&gt;A&lt;/code&gt;に対する syntax &lt;code&gt;X = A[I_1, I_2, ..., I_n]&lt;/code&gt; は &lt;code&gt;X = getindex(A, I_1, I_2, ..., I_n)&lt;/code&gt; と等価です。詳細は、&lt;a href=&#34;http://docs.julialang.org/en/latest/manual/arrays/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multi-dimensional Arrays&lt;/a&gt;や&lt;a href=&#34;http://docs.julialang.org/en/latest/stdlib/base/?highlight=getindex#Base.getindex&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;標準ライブラリのドキュメント&lt;/a&gt; を参考にしてください&lt;/p&gt;
&lt;p&gt;さて、正解を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# Array{T,2} -&amp;gt; Array{Ptr{T}}
function ptrarray2d{T&amp;lt;:Real}(src::Array{T,2})
    dst = Array{Ptr{T}, size(src, 2))
    for i=1:size(src, 2)
         dst[i] = pointer(sub(src, 1:size(src,1), i), 1)
    end
    dst
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;違いは &lt;code&gt;SubArray&lt;/code&gt;を使うようになった点です。&lt;code&gt;SubArray&lt;/code&gt;は、indexingを行うときにコピーを作らないので、期待した通りに&lt;code&gt;i&lt;/code&gt;列目の先頭要素のポインタを取得することができます。&lt;code&gt;SubArray&lt;/code&gt;について、以下引用しておきます&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SubArray is a specialization of AbstractArray that performs indexing by reference rather than by copying. A SubArray is created with the sub() function, which is called the same way as getindex() (with an array and a series of index arguments). The result of sub() looks the same as the result of getindex(), except the data is left in place. sub() stores the input index vectors in a SubArray object, which can later be used to index the original array indirectly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用元: &lt;a href=&#34;http://docs.julialang.org/en/latest/manual/arrays/#implementation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multi-dimensional Arrays&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-変換した型をどのように元に戻すか&#34;&gt;3. 変換した型をどのように元に戻すか&lt;/h3&gt;
&lt;p&gt;Juliaで計算結果（上の例でいう &lt;code&gt;double** output&lt;/code&gt;）を受け取りたい場合、ポインタに変換した値をJuliaのArrayに戻す必要があります（必ずしもそうではないですが、まぁほぼそうでしょう）。つまり、&lt;code&gt;Array(Ptr{Float64},1)&lt;/code&gt;を&lt;code&gt;Array{Float64,2}&lt;/code&gt;したいわけです。幸いにも、これは&lt;code&gt;pointer_to_array&lt;/code&gt;を使うと簡単にできます。コードを以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;# ccallを実行した後の計算結果が coutput に格納されているとします
coutput::Array{Ptr{Float64},1}

# Cに渡した型 Array{Ptr{Float64},1} から Array{Float64,2}に変換
for i=1:length(coutput)
    output[:,i] = pointer_to_array(coutput[i], size(output, 1))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pointer_to_array&lt;/code&gt; は、その名前の通りの関数ですね。pointerをArrayに変換してくれます。&lt;/p&gt;
&lt;h3 id=&#34;1-2-3-をまとめる&#34;&gt;1, 2, 3 をまとめる&lt;/h3&gt;
&lt;p&gt;最後に、1, 2, 3の内容をまとめて、ポインタのポインタを引数にもつ関数のラッパー例を書いておきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;function fooo(input::Array{Float64,2})
    h, w = size(intput)
    output = Array(Float64, h, w)

    # C関数に渡す用の変数
    cinput::Array{Ptr{Float64}} = ptrarray2d(input)
    coutput::Array{Ptr{Float64}} = ptrarray2d(output)

    ccall(:fooo, &amp;quot;libfooo&amp;quot;, Void,
    		 (Ptr{Ptr{Float64}}, Int, Int, Ptr{Ptr{Float64}}),
    		 cinput, w, h, coutput)

    # coutputをJuliaのArrayに変換
    for i=1:length(coutput)
        output[i,:] = pointer_to_array(coutput[i], h)
    end

    output
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ポインタのポインタまとめ&#34;&gt;ポインタのポインタまとめ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array&lt;/code&gt;のindexingはコピーを作るのである要素のポインタがほしい時は注意&lt;/li&gt;
&lt;li&gt;行/列の先頭のポインタがほしいときは &lt;code&gt;SubArray&lt;/code&gt; を使いましょう&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;ポインタにまつわるハマりどころとその解決法を紹介しました。今回紹介したものはすべて &lt;a href=&#34;https://github.com/r9y9/WORLD.jl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WORLD.jl&lt;/a&gt; という &lt;a href=&#34;http://ml.cs.yamanashi.ac.jp/world/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;音声分析変換合成システムWORLD&lt;/a&gt; のラッパーを書いていたときに得た知見です。やっと&lt;code&gt;WORLD.jl&lt;/code&gt;が安定して動くようになってきて公式パッケージにしようかなぁと考えているところですので、興味のある方はぜひ触ってみてください。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;immutableでなければいけない理由はまだよくわかっていないのですが、少なくとも &lt;a href=&#34;https://github.com/JuliaLang/julia/pull/8948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#8948&lt;/a&gt; にはそう書いてあります&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;たちの悪いことに、この実装でもだいたい上手く動くんですよね…。数値型がimmutableだからコピーしてもそうそうアドレスが変わらないとかそういう理由だろうかと考えていますが、ちょっとよくわかっていないです&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;ArrayとSubArrayの使い分けはどうすればいいのか、それぞれどういう目的で作られたのか等、僕も勉強中で理解が曖昧なため説明できません、すみません。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
